namespace Psq
open System
open System.Collections
open System.Collections.Generic


// An implementation of a priority search queue as described in the paper "A Simple Implementation Technique for 
// Priority Search Queues" by R. Hinze.
module internal PSQ = 

   // The priority search queue is defined in terms of a semi-heap strucure called a pennant.  This pennant is described
   // in relation to a tournament tree, hence the winner and loser nomenclature. Note that winnerKey and winnerValue
   // logically form a tuple/pair, but they are split out into discrete properties for efficiency. Also note that
   // the loser tree has its length as a discrete property to ensure constant-time access.
   type Pennant<'K, 'V when 'V: comparison> = 
      | Void
      | Winner of winnerKey:'K * winnerValue: 'V * ltree:LoserTree<'K, 'V> * maxKey:'K
   and LoserTree<'K, 'V> =
      | Start 
      | Loser of loserKey:'K * loserValue:'V * left:LoserTree<'K, 'V> * splitKey:'K * right:LoserTree<'K, 'V> * length:int 


   // An empty pennant.
   let empty : Pennant<'K, 'V> = Void


   // Returns a value indicating if the pennant is empty.  This is O(1).
   let isEmpty = function 
      | Void -> true
      | _ -> false


   // Returns the number of items in the pennant. This is O(1).
   let length = function
      | Void -> 0
      | Winner( _, _, Start, _) -> 1
      | Winner( _, _, Loser(_, _, _, _, _,length), _) -> length + 1


   // Returns the number of items in the tree.  This is O(1).
   let lengthTree = function
      | Start -> 0
      | Loser(_, _, _, _, _,length) -> length


   // Returns a pennant containing the specified key and value.
   let inline singleton key value = 
      Winner( key, value, Start, key)


   // Returns a pennant containing the key and value of the specified pair.
   let inline ofTuple (key, value) = 
      singleton key value


   // Returns the minimum key and value in the pennant, or throws if pennant is empty.  This is O(1).
   let minBinding = function
      | Void -> invalidOp "empty pennant"
      | Winner( k, v, _, _) -> k, v


   // Returns the minimum key and value in the pennan, or None if the pennant is empty.  This is O(1).
   let peekMinBinding = function
      | Void -> None
      | Winner( k, v, _, _) -> Some(k, v)
      

   // Returns the key of the binding with the maximum value in the pennant.  This is O(1).
   let maxKey = function
      | Void -> invalidOp "empty pennant"
      | Winner( _, _, _, max) -> max

 
   // Merges two pennants and returns a new pennant, such that keys in the first tree are strictly smaller than keys 
   // in the second tree. This is O(1).
   let private merge pennant1 pennant2 = 
      match pennant1, pennant2 with
      | Void, _ -> pennant2
      | _, Void -> pennant1
      | Winner( key1, value1, ltree1, max1), Winner( key2, value2, ltree2, max2) ->
         let lengthTrees = (lengthTree ltree1) + (lengthTree ltree2)
         if value1 < value2 then
            Winner( key1, value1, (Loser(key2, value2, ltree1, max1, ltree2, lengthTrees + 1)), max2)
         else
            Winner( key2, value2, (Loser(key1, value1, ltree1, max1, ltree2, lengthTrees + 1)), max2)


   // Returns a pennant containing values from the specified list, which *must* be sorted by key, in ascending order.
   // This is O(N).
   let fromOrderedList (bindings: list<'K *'V>) : Pennant<'K, 'V> = 
      // A variation of left and right fold that folds a list in a binary sub-division fashion, producing an almost 
      // balanced tree. The  expression tree  generated by foldm takes the form of a leaf-oriented Braun tree: for any 
      // given subexpression f l r , the left part l has either the same number of leaves as the right part, or one leaf 
      // more. 
      let foldm f state items =
         match items with
         | [] -> state
         | _ -> 
            let rec recurse length items = 
               match length, items with
               | 1, (x::xs) -> x, xs
               | n, xs ->
                  let m = n / 2
                  let x1, xs1 = recurse (n - m) xs
                  let x2, xs2 = recurse m xs1
                  f x1 x2, xs2
            fst (recurse (List.length items) items)

      let asPennants = bindings |> List.map ofTuple
      asPennants
      |> foldm( fun pennant singleton ->
         merge pennant singleton ) empty


    // Active pattern for extracting the minumum value from the pennant.
   module PriorityQueueView = 
     
      // If the pennant is not empty, Min is returned and carries the key and value of the minimum entry in the pennant, 
      // and an updated pennant with the minumum entry removed.  Otherwise Empty is returned.
      let (|Empty|Min|) pennant = 

         // Returns the second best entry from the tree, by effectively 'replaying' the tournament without the winner.
         let rec secondBest loserTree key  = 
            match loserTree, key with
            | Start, _ -> Void
            | Loser(loserKey, loserValue, ltree, splitKey, rtree, _), m ->
               if loserKey <= splitKey then
                  merge (Winner(loserKey, loserValue, ltree, splitKey)) (secondBest rtree m)
               else 
                  merge (secondBest ltree splitKey) (Winner(loserKey, loserValue, rtree, m))

         match pennant with
         | Void -> Empty
         | Winner(key, value, ltree, maxKey) -> Min( key, value, (secondBest ltree maxKey))


   // Active pattern for viewing the pennant as a tournament tree.  That is, a pennant is either
   // - Empty
   // - Singleton: A tree containing single entry
   // - Merged: The result of merging two pennants to determine a winner.  This is effectively the inverse of the
   // merge function.
   module TournamentView = 
      let (|Empty|Singleton|Merged|) pennant = 
         match pennant with
         | Void -> Empty
         | Winner(key, value, Start, _) -> Singleton(key, value)
         | Winner(key, value, (Loser(lkey, lvalue, leftTree, splitKey, rightTree, _)), maxKey) ->         
            let pennant1, pennant2 = 
               if lkey <= splitKey then
                  Winner(lkey, lvalue, leftTree, splitKey), Winner(key, value, rightTree, maxKey)
               else
                  Winner(key, value, leftTree, splitKey), Winner(lkey, lvalue, rightTree, maxKey)
            Merged(pennant1, pennant2)


   // Returns the value associated with the specified key in the pennant, or None if there is no such entry.  This is
   // O(lgN) on average.  
   let rec lookup key pennant = 
      match pennant with
      | PriorityQueueView.Min(k, v, _) when k = key -> Some(v)
      | TournamentView.Empty -> None
      | TournamentView.Singleton(k, v) -> None // k = key handled by Min case
      | TournamentView.Merged(pennant1, pennant2) ->
         if key <= maxKey pennant1 then lookup key pennant1
         else lookup key pennant2

   
   // Returns pennant, with the value of the specifiedd key adjusted by applying the specied function to the current 
   // value. This is O(lgN) on average.
   let rec adjust f key pennant = 
      match pennant with 
      | TournamentView.Empty -> 
         pennant
      | TournamentView.Singleton(k, v) -> 
         if k = key then singleton k (f v) else pennant
      | TournamentView.Merged(pennant1, pennant2) -> 
         if key <= maxKey pennant1 then 
            merge (adjust f key pennant1) pennant2
         else 
            merge pennant1 (adjust f key pennant2) 


   // Inserts the specified key and value into pennant, and returns an updated pennant.  If the pennant already 
   // contains the key, the corresponding value is replaced.  This is O(lgN) on average. Note that because no 
   // effort is made to balance loser trees, deeply lopsided trees amy be produced aftre multiple insertions.
   let rec insert key value pennant = 
      match pennant with 
      | TournamentView.Empty -> 
         singleton key value
      | TournamentView.Singleton(k, _) -> 
         if key < k then merge (singleton key value) pennant
         elif key = k then singleton key value  // Update existing value
         else merge pennant (singleton key value) 
      | TournamentView.Merged(pennant1, pennant2) -> 
         if key <= maxKey pennant1 then 
            merge (insert key value pennant1) pennant2
         else 
            merge pennant1 (insert key value pennant2) 


   // Removes the entry with the specified key from the pennant, and returns an updated pennant, and a flag indicating 
   // if an item was removed.
   let rec delete key pennant = 
      match pennant with 
      | TournamentView.Empty -> 
         pennant
      | TournamentView.Singleton(k, _) -> 
        if key = k then empty else pennant
      | TournamentView.Merged(pennant1, pennant2) -> 
         if key <= maxKey pennant1 then 
            merge (delete key pennant1) pennant2
         else 
            merge pennant1 (delete key pennant2)


   // Returns a list of entries, ordered by key, that contain values from the specified pennant that are less than or 
   // equal to the specified value.
   let rec atMost value pennant = 
      match pennant with
      | PriorityQueueView.Min(_, v, _) when v > value -> []
      | TournamentView.Empty -> []
      | TournamentView.Singleton(k, v) -> [(k, v)] // Since we know v <= value
      | TournamentView.Merged(pennant1, pennant2) ->
         List.append (atMost value pennant1) (atMost value pennant2) 
            

   // Iterator class for a pennant
   type PennantEnumerator<'K, 'V when 'K: comparison and 'V: comparison> ( pennant : Pennant<'K, 'V> ) =
      let notStarted() = 
         raise <| new InvalidOperationException("The enumerator has not been started by a call to MoveNext")
      let alreadyCompleted() = 
         raise <| new InvalidOperationException("The enumerator has already completed.")

      let mutable currentPennant = pennant
      let mutable isStarted = false

      // Get the current item in the enumerator
      let current() =
         if isStarted then 
            let k, v = minBinding currentPennant
            new KeyValuePair<'K, 'V>(k, v)
         else notStarted()
      
      // Positions the enumerator at the next item in the collection
      let moveNext() =
         if isStarted then 
            match currentPennant with 
            | PriorityQueueView.Empty -> alreadyCompleted()
            | PriorityQueueView.Min( _, _, rest) ->
               currentPennant <- rest
               not(currentPennant |> isEmpty)
         else
             isStarted <- true;
             not (currentPennant |> isEmpty)
 
      interface IEnumerator<KeyValuePair<'K, 'V>> with
         member x.Current = current()
      interface IEnumerator with 
         member x.Current = box (current())
         member x.MoveNext() = moveNext()
         member x.Reset() = currentPennant <- pennant
      interface IDisposable with 
         member x.Dispose() = () 

      
// Documention in signature file
[<Sealed>]
type PrioritySearchQueue<'K, 'V when 'K: comparison and 'V: comparison> internal( pennant: PSQ.Pennant<'K, 'V>  ) = 

   static let collectionIsReadOnly() = 
      new InvalidOperationException("The operation is not valid because the collection is read-only.")
   
   static let empty = 
      new PrioritySearchQueue<'K, 'V>( PSQ.empty )

   member this.Length = 
      PSQ.length pennant

   member this.IsEmpty = 
      this.Length = 0

   member this.Min = 
      PSQ.minBinding pennant

   member this.PeekMin = 
      PSQ.peekMinBinding pennant
     
   member this.Find key = 
      match PSQ.lookup key pennant with
      | Some(value) -> value
      | None -> raise (KeyNotFoundException(sprintf "%A" key))

   member this.TryFind key = 
      PSQ.lookup key pennant 
      
   member this.Item 
      with get(key:'K) = this.Find(key)

   member this.Add(key, value) =
      new PrioritySearchQueue<'K, 'V>( PSQ.insert key value pennant )

   member this.Remove key =
      new PrioritySearchQueue<'K, 'V>( PSQ.delete key pennant  )

   member this.AtMost value =
      PSQ.atMost value pennant 

   static member Empty : PrioritySearchQueue<'K, 'V> = 
      empty

   interface IEnumerable with
      member x.GetEnumerator() = 
         new PSQ.PennantEnumerator<'K, 'V>( pennant ) :> IEnumerator

   interface IEnumerable<KeyValuePair<'K, 'V>> with
      member x.GetEnumerator() = 
         new PSQ.PennantEnumerator<'K, 'V>( pennant ) :> IEnumerator<KeyValuePair<'K, 'V>>


// Documention in signature file
[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module PrioritySearchQueue =
   
   let empty<'K, 'V when 'K: comparison and 'V: comparison> = 
      PrioritySearchQueue<'K, 'V>.Empty

   let isEmpty (queue:PrioritySearchQueue<'K, 'V>) = 
      queue.IsEmpty

   let ofOrderedSeq (items:seq<'K*'V>) = 
      new PrioritySearchQueue<'K, 'V>( PSQ.fromOrderedList (List.ofSeq items) )

   let ofSeq (items:seq<'K*'V>) = 
      items |> Seq.sortBy fst |> ofOrderedSeq

   let min (queue:PrioritySearchQueue<'K, 'V>) = 
      queue.Min

   let peekMin (queue:PrioritySearchQueue<'K, 'V>) = 
      queue.PeekMin

   let toSeq (queue:PrioritySearchQueue<'K, 'V>) = 
      queue
      |> Seq.map( fun pair -> pair.Key, pair.Value )

   let find (key:'K) (queue:PrioritySearchQueue<'K, 'V>) = 
      queue.Find key

   let tryFind (key:'K) (queue:PrioritySearchQueue<'K, 'V>) = 
      queue.TryFind key
      
   let add (key:'K) (value:'V) (queue:PrioritySearchQueue<'K, 'V>) = 
      queue.Add(key, value)

   let remove (key:'K) (queue:PrioritySearchQueue<'K, 'V>) = 
      queue.Remove key

   let atMost (value:'V) (queue:PrioritySearchQueue<'K, 'V>) = 
      queue.AtMost value
      